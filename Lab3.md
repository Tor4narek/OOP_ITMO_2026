# Лабораторная работа №3 - Async/await, файлы и JSON

## Цель работы

Освоение **асинхронного программирования (async/await)**, работы с **файловой системой и JSON**, а также создание **отдельной библиотеки для сериализации и десериализации**.

Расширение репозитория из ЛР-2 для хранения данных в файлах. Развитие навыков создания расширяемой архитектуры, где бизнес-логика отделена от способа хранения данных.


## Выбор варианта

Номер варианта — номер в журнале.

**[Список вариантов](/lab1_variants.md)**

Вариант определяется предметной областью, выбранной в ЛР-1 и ЛР-2.


## Общая идея приложения

Приложение сохраняет и загружает данные из **файлов JSON**, используя репозиторий.

* Все данные хранятся **на диске в JSON-файлах**.
* Используется **универсальный репозиторий** (`IRepository<T>`).
* Реализация репозитория должна быть **асинхронной**.
* Студенты расширяют проект из ЛР-2, не меняя бизнес-логику приложения.
* Пути к файлам и конфигурация хранятся в отдельном файле конфигурации (`appsettings.json` или `application.json`).


## Техническое задание

### 1. Библиотека для работы с JSON

**Задача:**

Создать отдельную библиотеку `JsonHelper` для **асинхронной сериализации и десериализации** данных в JSON.

#### Требования:

* В библиотеке реализовать методы:

```csharp
public static class JsonHelper
{
    Task SaveAsync<T>(string path, IEnumerable<T> data);
    Task<List<T>> LoadAsync<T>(string path);
}
```

* Реализовать **асинхронную работу с файлами** (`FileStream` + `JsonSerializer`).
* Обеспечить корректную сериализацию и десериализацию **любых типов сущностей**.
* Библиотека должна быть **типобезопасной** и не использовать dynamic/object.
* Исключения должны корректно обрабатываться или прокидываться выше.


### 2. Асинхронный файловый репозиторий

**Задача:**

Создать новую реализацию интерфейса `IRepository<T>` для работы с файлами через `JsonHelper`.

#### Требования:

* Интерфейс `IRepository<T>` из ЛР-2:

```csharp
public interface IRepository<T> where T : IEntity
{
    Task AddAsync(T entity);
    Task<IReadOnlyList<T>> GetAllAsync();
    Task<T?> GetByIdAsync(Guid id);
    Task RemoveAsync(Guid id);
    Task<IReadOnlyList<T>> FindAsync(Func<T, bool> predicate);
}
```

* Создать класс `FileRepository<T>`:

  * Хранение данных в **JSON-файле**.
  * Использовать **только методы `JsonHelper`** для чтения/записи.
  * Методы должны быть **асинхронными**.
  * Репозиторий должен инициализировать коллекцию при запуске и сохранять изменения при добавлении или удалении элементов.
  * Использовать коллекцию `List<T>` внутри репозитория.
  * `FindAsync(Func<T,bool>)` использовать для фильтрации.

* Пример использования:

```csharp
IRepository<User> userRepository = new FileRepository<User>("users.json");
await userRepository.AddAsync(new User { Name = "Alex" });

var foundUsers = await userRepository.FindAsync(u => u.Name.StartsWith("A"));
```


### 3. Интеграция с приложением

**Задача:**

Заменить `InMemoryRepository<T>` на `FileRepository<T>` в существующем проекте ЛР-2.

#### Требования:

* В `Main` приложения и сервисах использовать **только `IRepository<T>`**, не изменяя бизнес-логику.
* Все действия (добавление, удаление, поиск) выполняются через **асинхронные методы**.
* Пути к файлам конфигурируются через JSON (`appsettings.json`):

```json
{
  "UsersFile": "users.json",
  "OrdersFile": "orders.json"
}
```


### 4. Расширение функционала

* Можно добавить **методы обновления (`UpdateAsync`)** или расширенные фильтры.
* Все операции должны быть асинхронными (`Task`) и использовать `await`.
* Архитектура должна позволять в будущем добавить **другие типы хранилищ** (БД, облако).


## Требования к реализации

В программе обязательно должно быть использовано:

* `class`, `interface`, Generics (`<T>`),
* `async / await`, `Task`,
* работа с файлами (`FileStream`),
* JSON сериализация/десериализация через `JsonHelper`,
* `Func<T, bool>` (делегаты) и лямбда-выражения,
* `IReadOnlyList<T>` и коллекции `List<T>`.

### Разрешено:

* Коллекции (`List<T>`),
* Консольный ввод/вывод,
* Стандартные библиотеки C#.

### Запрещено:

* LINQ (можно оставить для отчетов предыдущей лабораторной),
* Внешние библиотеки кроме `System.Text.Json`,
* Базы данных.


## Критерии оценки

### Код программы (6 баллов):

* **2 балла** — корректная работа `FileRepository<T>` и `JsonHelper`,
* **2 балла** — логичная и расширяемая архитектура,
* **2 балла** — асинхронные операции корректно реализованы.

### Защита работы (6 баллов):

* **1 балл** — объяснение архитектуры репозитория и библиотеки `JsonHelper`,
* **2 балла** — обоснование проектных решений и выбора асинхронного подхода,
* **3 балла** — ответы по темам лекций 4 (Task, async/await, файлы, JSON).


## Полезные ссылки

* [Async/await в C#](https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/concepts/async/)
* [Асинхронная работа с файлами](https://learn.microsoft.com/ru-ru/dotnet/standard/io/asynchronous-file-i-o)
* [JSON сериализация/десериализация](https://learn.microsoft.com/ru-ru/dotnet/standard/serialization/system-text-json-how-to)
* [Работа с конфигурацией через JSON](https://learn.microsoft.com/ru-ru/dotnet/core/extensions/configuration)
* [Generics и интерфейсы](https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/generics/)
